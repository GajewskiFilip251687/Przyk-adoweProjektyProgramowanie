# -*- coding: utf-8 -*-
"""KompObl2.Project1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ICbTIf5R6DaOnoImlRWhW8ADmcbV2UJB
"""

# importujemy potrzebne nam biblioteki, timeit do mierzenia czasu a math do funkcji floor
import timeit as tm
import math as m


# funkcja wykonująca algorytm rekurencyjny
def recursive_extended_euclid(a, b):
    if b == 0:
        return (1, 0, nwd)
    else:
        (x, y, d) = recursive_extended_euclid(b, a % b)
        return (y, x - m.floor(a/b)*y, d)


# funkcja wykonująca algorytm iteracyjny
def iterative_extended_euclid(a, b):
    x_prev = y_cur = 1
    y_prev = x_cur = 0
    while b != 0:
        q = m.floor(a/b)
        r = a % b
        a, b = b, r
        x_new = x_prev - q*x_cur
        y_new = y_prev - q*y_cur
        x_prev = x_cur
        y_prev = y_cur
        x_cur = x_new
        y_cur = y_new
    return (x_prev, y_prev, nwd)


# funkcja główna main
if __name__ == '__main__':
    # 1.Wczytujemy do programu dane na których będziemy operować
    num_a = 4283
    num_b = 2627
    num_m = 255877

    x, y, nwd = iterative_extended_euclid(num_a, num_m)
    if nwd == 1:
        # TEORETYCZNIE JEST TO WARUNEK W ZADANIU, LECZ MY TEGO NIE WYKORZYSTUJEMY
        None

    # Znajdowanie x
    a_inverse = x % num_m  # Liczba odwrotna a mod m
    x_solution = (a_inverse * num_b) % num_m  # Obliczenie x

    # 2.Obliczamy czasy poszczególnych programów
    average_time_rec = average_time_iter = recur_time = iter_time = 0  # deklarujemy zmienne
    for i in range(100_001): # Ponieważ pętla for wykonuje się (range - 1)- razy
        # teraz obliczamy średni czas dla algorytmu rekurencyjnego
        time1 = tm.default_timer()
        recursive_extended_euclid(i, num_m)
        recur_time = tm.default_timer() - time1
        average_time_rec += recur_time
        # teraz obliczamy średni czas dla algorytmu iteracyjnego
        time2 = tm.default_timer()
        iterative_extended_euclid(i, num_m)
        iter_time = tm.default_timer() - time2
        average_time_iter += iter_time
    # dzielimy średnie czasy przez 1000 ponieważ tysiąc razy dodajemy poszczególne wyniki
    average_time_rec /= 100_000
    average_time_iter /= 100_000

    # 3.Wyświetlamy wyniki na ekranie konsoli
    print(f'Liczby całkowite t, s są takie, żę at + ms = 1. Wtedy t = {x}, s = {y}')
    print(f'a^(-1) (mod m) = {a_inverse}')
    print(f'Rozwiązaniem równania: "(ax) mod m = b" jest x = {x_solution}')
    print(f'Średni czas wykonania algorytmu rekurencyjnego: {average_time_rec}')
    print(f'Średni czas wykonania algorytmu iteracyjnego: {average_time_iter}')
    print(f'Iloraz średnich czasów rekurencyjnego do iteracyjnego wynosi: {average_time_rec / average_time_iter}')