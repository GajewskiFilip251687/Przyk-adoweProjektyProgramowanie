# -*- coding: utf-8 -*-
"""LabyProjektMscZeroweBisekcja.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EoOM7HhVmOAnUhBhBqR8GLDFftXjSDLS
"""

# importujemy potrzebne biblioteki
import numpy as np
import matplotlib.pyplot as plt
from math import floor


#definiujemy funkcje w programie która oblicza matematyczną wartość zadanego wyrażenia
def f(x):
    return 3 * np.cos(x ** 1.6) + 0.1


#definiujemy funkcję, która wyznacza miejsca zerowe algorytmem bisekcji
def bisect(left, right, epsilon):
    mid = 0
    if (f(left) * f(right) <= 0):
      while abs(right - left) > epsilon**2:
          mid = (left + right)/2
          if f(mid) == 0:
              break
          if f(left) * f(mid) < 0:
              right = mid
          else:
              left = mid
    elif (f(left) * f(right) >= 0):
        #print(f"Komunikat: Znaki dla lewego końca i środka przedziału są takie same.")
        return None
    return mid


#definiujemy funkcję która wyznacza nam przedziały w których są miejsca zerowe (z Darboux)
def zero_intervals(x, y):
  left = []
  right = []
  for i in range(0, len(args)-1):
    if y[i] * y[i+1] < 0:
      left.append(x[i])
      right.append(x[i+1])
  return left, right


#definiujemy zmienne
l_end = 2     #lewy koniec przedziału który nas interesuje
r_end = 10     #prawy koniec przedziału
digits = 6      #dokladnosc wyniku
d = 0.2     #odleglosc niemniejsza miedzy msc zerowymi
N = floor((r_end - l_end) / d) + 1     #liczba wygenerowanych arg
accuracy = 1/10**digits   #dokładność obliczeń
arr_of_zeros = []   #pusta tablica na liste miejsc zerowych


#przypisujemy wartości zmiennym istotnym dla działania programu
args = np.linspace(l_end, r_end, N)
values = f(args)
left, right = zero_intervals(args, values)
for i in range(0, len(left)):
  arr_of_zeros.append(bisect(left[i], right[i], accuracy))


# wyświetlanie informacji potrzebnych w sprawozdaniu
print(f"Ilość wygenerowanych argumentów (pod przedziałów): {N}")
print(f"Ilość miejsc zerowych tej funkcji na przedziale [{l_end},{r_end}]: {len(arr_of_zeros)}")
print(f"\nNajmniejsze miejsce zerowe: {round(min(arr_of_zeros), digits)}")
print(f"Najmniejsze miejsce zerowe: {round(max(arr_of_zeros), digits)}")


#wyswietlanie na ekran miejsc zerowych funkcji
print("\nZnalezione miejsca zerowe:")
for i in range(0, len(arr_of_zeros)):
    print(f"x{i+1} = {round(arr_of_zeros[i], digits)}")



#za pomocą biblioteki generujemy wykres funkcji z zaznaczonymi punktami charakterystycznymi
args_x = np.linspace(l_end, r_end, floor((r_end - l_end) * 10**digits) + 1)   #tworzenie listy argumentów - odpowiednio dużej aby wykres był gładki
values_y = f(args_x)
plt.scatter(arr_of_zeros, [0 for k in range(0, len(arr_of_zeros))], c='#ed092f', s=30,  label="Msc zerowe")   #rysowanie punktów (msc zerowych)
plt.plot(args_x, values_y)    #rysowanie wykresu funkcji
plt.grid(which='major', ls='-.')    #generowanie podziałki na wykresie "w tle" (siatka na wykresie)
plt.plot([l_end, r_end], [0, 0], '--', c='k')   #generowanie osi OX
plt.plot([0, 0], [-5, 5], '--', c='k')   #generowanie osi OY
plt.legend(loc="upper left")    #umiejscowienie legendy wykresu (lewy górny róg)
plt.show()    #wygenerowanie wykresu z dodanymi powyżej komponentami